# JavaScript

## 적용 방법

### 인라인

```html
<element onclick="">content</element>
<!--
	요소에 직접 입력하는 방식
	동작에 맞춰 CSS를 바꾸는 등의 간단한 것만 가능함
-->
```

### 내부 자바스크립트 코드

```html
<script type="text/javascript">
	document.write("<h1 style="color=blue">내부 자바스크립트 코드</h1>");
<script>
<!--
	HTML의 script 태그 안에 코드를 입력하는 방식
	script 태그 안에 HTML과 CSS 모두 사용 가능
-->
```

### 외부 자바스크립트 코드

```html
<!-- HTML -->
<script type="text/javascript" scr="JS 파일 경로">
	<!-- 내부에 입력X: 입력해도 적용안됨 -->
<script>
```

```jsx
/* JavaScript */
<element onclick="">content</element>

/* 	외부 JS파일을 가져오는 방식 */
```

## 변수

### 선언 방법

```jsx
/* JS 변수 선언 방법 */

var 변수이름;
let 변수이름;
const 변수이름 = 값;
변수이름;
/*
	전역 변수의 경우 var, let, const 생략 가능
	지역 변수에서 생략할 경우 전역 변수로 생성됨
	but 변수가 생성된 함수가 호출된 뒤에만 전역 변수로 사용 가능
*/
```

### 특징

- JS는 값이 할당된 뒤에 변수의 타입이 결정됨(하나의 변수에 모든 타입의 변수 입력 가능)
- new로 생성한 변수는 무엇이 들어있든 Object 타입이 됨
- 초기화하지 않은 변수 타입과 값은 undefined로 설정됨
- 선호출 후생성 가능(생성 없이 호출만 할 경우 에러 발생) → 호이스팅 개념
but 선호출할 경우 변수 타입과 값은 undefined로 설정됨
- 호이스팅
    - 브라우저가 파일을 읽을 때 사용 여부와 관계없이 선언된 객체, 변수, 함수를 메모리에 미리 올리는 방식
    - 사용될 때 초기화 문장을 만나면 초기화함
    - 때문에 이름이 같을 경우 객체, 변수, 함수 등이 섞여 호출될 수 있음
    이를 막기 위해 let, const로 변수를 선언함
- let, const
    - let은 값 변경 가능
    - const(상수)는 생성 시 초기화 필수, 값 변경 불가
    - let, const 모두 변수 재선언, 선호출 후생성, 지역 변수 블럭 외 호출 불가
	
## 연산자

### 산술 연산자

```jsx
a + b // a에 b를 더함
a - b // a에서 b를 뺌
a * b // a와 b를 곱함
a / b // a를 b로 나눔
a % b // a를 b로 나눈 나머지를 구함
```

### 연결 연산자

```jsx
"a" + "b" // a에 b를 연결함
```

### 비교 연산자

```jsx
a == b // a와 b가 같으면 true
a != b // a와 b가 다르면 true
a < b // a보다 b가 크면 true
a <= b // a보다 b가 크거나 같으면 true
a > b // a보다 b가 작으면 true
a >= b // a보다 b가 작거나 같으면 true
```

### 대입 연산자

```jsx
a = b // a에 b를 대입
a += b // a에 b를 더해서 a에 대입
a -= b // a에서 b를 빼서 a에 대입
a *= b // a에 b를 곱해서 a에 대입
a /= b // a를 b로 나눠서 a에 대입
a %= b // a를 b로 나눈 나머지를 a에 대입
```

### 논리 연산자

```jsx
a && b // a와 b가 모두 true면 true
a || b // a와 b 중 하나가 true면 true 
a ^ b // a와 b의 값이 다르면 true
```

### 삼항 연산자

```jsx
(조건) ? 참일 때 결과 : 거짓일 때 결과
```

### 증감 연산자

```jsx
a++ // 실행 뒤 a에 1을 더함
++a // a에 1을 더한 뒤 실행
a-- // 실행 뒤 a에 1을 뺌
--a // a에서 1을 뺀 뒤 실행
```

### 연결 연산자

```jsx
`아바바바 ${변수}` 변수와 글자를 함께 쓸 때 사용 템플릿 문자열
```

## 제어문

### 조건문

- if문
    
    ```jsx
    // 자바와 if문 구성이 동일함
    
    if(조건문 1) { // 조건문 1이 true이면 실행문 1 실행
    	실행문 1;
    } else if(조건문 2) { // 조건문 1이 false고 실행문 2가 true면 실행문 2 실행
    	실행문 2;
    } else { // 조건문 1과 2 모두 false면 실행문 3 실행
    	실행문 3;
    }
    ```
    
- switch문
    
    ```jsx
    // 자바와 switch문 구성이 동일함
    
    switch(변수) {
    	case 값: // 변수와 값이 같으면 아래의 실행문 실행
    		실행문 1;
    		break;
    	case 값:
    		실행문 2;
    		break;
    	default: // 변수와 같은 값이 없으면 default 아래의 실행문 실행
    		실행문 3;
    }
    ```
    
### 반복문

- for문
    
    ```jsx
    // 자바와 for문 구성이 동일함
    
    for(초기값; 조건식; 증감식) { // 조건식이 true인 동안 실행
    	실행문;
    }
    ```
    
- do-while문
    
    ```jsx
    // 자바와 do-while문 구성이 동일함
    
    do { // 조건식이 true인 동안 실행하되, 조건식이 false여도 한 번은 실행
    	실행문;
    } while(조건식)
    ```
    
- switch문
    
    ```jsx
    // 자바와 switch문 구성이 동일함
    
    switch(변수) {
    	case 값:
    		실행문 1;
    		break;
    	case 값:
    		실행문 2;
    		break;
    	default:
    		실행문 3;
    }
    ```
    

## 함수

### 선언&호출 방법

```jsx
// 선언적 함수 선언
function 함수명(매개변수, 매개변수...){
	실행문;
	return 리턴값;
}

// 선언적 함수 호출
함수명; // 함수
함수명(); // 리턴값
// 매개변수의 갯수가 달라도 호출되기 때문에 오버로딩할 필요X
// 오버로딩할 경우 맨 마지막에 생성된 함수만 호출됨

// 익명 함수 선언
let 변수명 = function(매개변수, 매개변수...){
	실행문;
	return 리턴값;
}

// 익명 함수 호출
result = 변수명; // 함수
result = 변수명(); // 리턴값
```

### 대화상자 함수

```jsx
alert("문자열"); // 대화상자로 문자열 출력
prompt("문자열", "초기값") // 프롬프트 창으로 문자열을 출력하고 문자열을 입력받음
confirm("문자열") // 대화상자로 문자열 출력 뒤 확인(true), 취소(false) 입력받음
```

### 문자 → 숫자 변환 함수

```jsx
Number(문자열);
/*
	문자열을 정수형으로 바꾸되, 문자가 섞여있을 경우 NaN(Not a Number)가 도출됨
*/

parseint(문자열);
/*
	실수를 넣을 경우 소숫점을 머리고 정수형으로 바꿈
	문자열이 숫자일 경우 정수형으로 바꿈
	문자열이 숫자로 시작할 경우 이어지는 숫자만 추출해 정수형으로 바꿈
	문자열이 문자로 시작할 경우 NaN(Not a Number)가 도출됨
*/
```